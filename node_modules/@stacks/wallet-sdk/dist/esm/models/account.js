import { HDKey } from '@scure/bip32';
import { makeAuthResponse as _makeAuthResponse } from '@stacks/auth';
import { bytesToHex, utf8ToBytes } from '@stacks/common';
import { createFetchFn } from '@stacks/common';
import { getPublicKeyFromPrivate, hashCode, hashSha256Sync, publicKeyToBtcAddress, } from '@stacks/encryption';
import { getAddressFromPrivateKey } from '@stacks/transactions';
import { connectToGaiaHubWithConfig, getHubInfo, makeGaiaAssociationToken, } from '../utils';
import { HARDENED_OFFSET } from './common';
import { DEFAULT_PROFILE, fetchAccountProfileUrl, fetchProfileFromUrl, signAndUploadProfile, } from './profile';
export function getStxAddress(accountOrOptions, network = 'mainnet') {
    if ('account' in accountOrOptions) {
        const { account, network = 'mainnet' } = accountOrOptions;
        return getAddressFromPrivateKey(account.stxPrivateKey, network);
    }
    return getAddressFromPrivateKey(accountOrOptions.stxPrivateKey, network);
}
export const getAccountDisplayName = (account) => {
    if (account.username) {
        return account.username.split('.')[0];
    }
    return `Account ${account.index + 1}`;
};
export const getAppPrivateKey = ({ account, appDomain, }) => {
    const hashBytes = hashSha256Sync(utf8ToBytes(`${appDomain}${account.salt}`));
    const hash = bytesToHex(hashBytes);
    const appIndex = hashCode(hash);
    const appsNode = HDKey.fromExtendedKey(account.appsKey);
    const appKeychain = appsNode.deriveChild(appIndex + HARDENED_OFFSET);
    if (!appKeychain.privateKey)
        throw 'Needs private key';
    return bytesToHex(appKeychain.privateKey);
};
async function optionalGaiaProfileData({ gaiaHubUrl, fetchFn, account, }) {
    const hubInfo = await getHubInfo(gaiaHubUrl, fetchFn).catch(() => undefined);
    if (!hubInfo)
        return {};
    const profileUrl = await fetchAccountProfileUrl({ account, gaiaHubUrl: hubInfo.read_url_prefix });
    const profile = (await fetchProfileFromUrl(profileUrl, fetchFn)) || DEFAULT_PROFILE;
    return { hubInfo, profileUrl, profile };
}
export const makeAuthResponse = async ({ account, appDomain, transitPublicKey, scopes = [], gaiaHubUrl, appPrivateKeyFromWalletSalt = null, additionalData = {}, fetchFn = createFetchFn(), }) => {
    const appPrivateKey = getAppPrivateKey({ account, appDomain });
    const { hubInfo, profileUrl, profile } = await optionalGaiaProfileData({
        gaiaHubUrl,
        fetchFn,
        account,
    });
    if (scopes.includes('publish_data') && hubInfo && profile) {
        if (!profile.apps) {
            profile.apps = {};
        }
        const publicKey = getPublicKeyFromPrivate(appPrivateKey);
        const address = publicKeyToBtcAddress(publicKey);
        const storageUrl = `${hubInfo.read_url_prefix}${address}/`;
        profile.apps[appDomain] = storageUrl;
        if (!profile.appsMeta) {
            profile.appsMeta = {};
        }
        profile.appsMeta[appDomain] = {
            storage: storageUrl,
            publicKey,
        };
        const gaiaHubConfig = connectToGaiaHubWithConfig({
            hubInfo,
            privateKey: account.dataPrivateKey,
            gaiaHubUrl,
        });
        await signAndUploadProfile({ profile, account, gaiaHubUrl, gaiaHubConfig });
    }
    const compressedAppPublicKey = getPublicKeyFromPrivate(appPrivateKey.slice(0, 64));
    const associationToken = makeGaiaAssociationToken({
        privateKey: account.dataPrivateKey,
        childPublicKeyHex: compressedAppPublicKey,
    });
    return _makeAuthResponse(account.dataPrivateKey, {
        ...(profile || {}),
        stxAddress: {
            testnet: getStxAddress({ account, network: 'testnet' }),
            mainnet: getStxAddress({ account, network: 'mainnet' }),
        },
        ...additionalData,
    }, profileUrl ? { profileUrl } : null, undefined, appPrivateKey, undefined, transitPublicKey, gaiaHubUrl, undefined, associationToken, appPrivateKeyFromWalletSalt);
};
//# sourceMappingURL=account.js.map