import { getNameInfo } from '@stacks/auth';
import { bytesToHex, utf8ToBytes } from '@stacks/common';
import { createSha2Hash } from '@stacks/encryption';
import { clientFromNetwork, networkFrom, } from '@stacks/network';
import { compressPrivateKey, getAddressFromPrivateKey } from '@stacks/transactions';
import { HARDENED_OFFSET } from './models/common';
import { fetchFirstName } from './usernames';
import { assertIsTruthy } from './utils';
const DATA_DERIVATION_PATH = `m/888'/0'`;
const WALLET_CONFIG_PATH = `m/44/5757'/0'/1`;
const STX_DERIVATION_PATH = `m/44'/5757'/0'/0`;
export const deriveWalletKeys = async (rootNode) => {
    assertIsTruthy(rootNode.privateKey);
    return {
        salt: await deriveSalt(rootNode),
        rootKey: rootNode.privateExtendedKey,
        configPrivateKey: bytesToHex(deriveConfigPrivateKey(rootNode)),
    };
};
export const deriveConfigPrivateKey = (rootNode) => {
    const derivedConfigKey = rootNode.derive(WALLET_CONFIG_PATH).privateKey;
    if (!derivedConfigKey)
        throw new TypeError('Unable to derive config key for wallet identities');
    return derivedConfigKey;
};
export const deriveLegacyConfigPrivateKey = (rootNode) => {
    const derivedLegacyKey = rootNode.deriveChild(45 + HARDENED_OFFSET).privateKey;
    if (!derivedLegacyKey)
        throw new TypeError('Unable to derive config key for wallet identities');
    return bytesToHex(derivedLegacyKey);
};
export const deriveSalt = async (rootNode) => {
    const identitiesKeychain = rootNode.derive(DATA_DERIVATION_PATH);
    const publicKeyHex = utf8ToBytes(bytesToHex(identitiesKeychain.publicKey));
    const sha2Hash = await createSha2Hash();
    const saltData = await sha2Hash.digest(publicKeyHex, 'sha256');
    return bytesToHex(saltData);
};
export var DerivationType;
(function (DerivationType) {
    DerivationType[DerivationType["Wallet"] = 0] = "Wallet";
    DerivationType[DerivationType["Data"] = 1] = "Data";
    DerivationType[DerivationType["Unknown"] = 2] = "Unknown";
})(DerivationType || (DerivationType = {}));
export const selectStxDerivation = async ({ username, rootNode, index, network, }) => {
    if (network)
        network = networkFrom(network);
    if (username) {
        const stxDerivationTypeForUsername = await selectDerivationTypeForUsername({
            username,
            rootNode,
            index,
            network,
        });
        return { username, stxDerivationType: stxDerivationTypeForUsername };
    }
    else {
        const { username, derivationType } = await selectUsernameForAccount({
            rootNode,
            index,
            network,
        });
        return { username, stxDerivationType: derivationType };
    }
};
const selectDerivationTypeForUsername = async ({ username, rootNode, index, network, }) => {
    if (network) {
        const nameInfo = await getNameInfo({ name: username });
        const stxPrivateKey = deriveStxPrivateKey({ rootNode, index });
        let derivedAddress = getAddressFromPrivateKey(stxPrivateKey);
        if (derivedAddress !== nameInfo.address) {
            const dataPrivateKey = deriveDataPrivateKey({
                rootNode,
                index,
            });
            derivedAddress = getAddressFromPrivateKey(dataPrivateKey);
            if (derivedAddress !== nameInfo.address) {
                return DerivationType.Unknown;
            }
            else {
                return DerivationType.Data;
            }
        }
        else {
            return DerivationType.Wallet;
        }
    }
    else {
        return DerivationType.Unknown;
    }
};
const selectUsernameForAccount = async (opts) => {
    const network = networkFrom(opts.network ?? 'mainnet');
    const client = Object.assign({}, clientFromNetwork(network), opts.client);
    if (opts.network) {
        const stxPrivateKey = deriveStxPrivateKey(opts);
        const address = getAddressFromPrivateKey(stxPrivateKey, opts.network);
        let username = await fetchFirstName({ address, client });
        if (username) {
            return { username, derivationType: DerivationType.Wallet };
        }
        else {
            const dataPrivateKey = deriveDataPrivateKey(opts);
            const address = getAddressFromPrivateKey(dataPrivateKey, opts.network);
            username = await fetchFirstName({ address, client });
            if (username) {
                return { username, derivationType: DerivationType.Data };
            }
        }
    }
    return { username: undefined, derivationType: DerivationType.Wallet };
};
export const fetchUsernameForAccountByDerivationType = async (opts) => {
    const network = networkFrom(opts.network ?? 'mainnet');
    const client = Object.assign({}, clientFromNetwork(network), opts.client);
    const privateKey = derivePrivateKeyByType(opts);
    const address = getAddressFromPrivateKey(privateKey, network);
    const username = await fetchFirstName({ address, client });
    return { username };
};
export const derivePrivateKeyByType = ({ rootNode, index, derivationType, }) => {
    return derivationType === DerivationType.Wallet
        ? deriveStxPrivateKey({ rootNode, index })
        : deriveDataPrivateKey({ rootNode, index });
};
export const deriveStxPrivateKey = ({ rootNode, index }) => {
    const childKey = rootNode.derive(STX_DERIVATION_PATH).deriveChild(index);
    assertIsTruthy(childKey.privateKey);
    return compressPrivateKey(childKey.privateKey);
};
export const deriveDataPrivateKey = ({ rootNode, index }) => {
    const childKey = rootNode.derive(DATA_DERIVATION_PATH).deriveChild(index + HARDENED_OFFSET);
    assertIsTruthy(childKey.privateKey);
    return compressPrivateKey(childKey.privateKey);
};
export const deriveAccount = ({ rootNode, index, salt, stxDerivationType, }) => {
    const stxPrivateKey = stxDerivationType === DerivationType.Wallet
        ? deriveStxPrivateKey({ rootNode, index })
        : deriveDataPrivateKey({ rootNode, index });
    const identitiesKeychain = rootNode.derive(DATA_DERIVATION_PATH);
    const identityKeychain = identitiesKeychain.deriveChild(index + HARDENED_OFFSET);
    if (!identityKeychain.privateKey)
        throw new Error('Must have private key to derive identities');
    const dataPrivateKey = bytesToHex(identityKeychain.privateKey);
    const appsKey = identityKeychain.deriveChild(0 + HARDENED_OFFSET).privateExtendedKey;
    return {
        stxPrivateKey,
        dataPrivateKey,
        appsKey,
        salt,
        index,
    };
};
//# sourceMappingURL=derive.js.map